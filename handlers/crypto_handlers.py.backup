from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from services.coinstats_service import coinstats_service
from services.direct_api_service import direct_api_service
from services.holderscan_service import holderscan_service
from utils.crypto_formatter import (
    format_market_overview, format_error_message,
    format_token_info, format_trending_tokens, format_holders_info
)
from config.constants import (
    CRYPTO_MENU, DEX_MENU, COIN_MENU, DEX_SUBMENU, COIN_SUBMENU,
    MAIN_MENU
)
from database.operations import check_subscription, check_user_api_limit, log_api_request
import asyncio

async def crypto_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """نمایش منوی رمزارز با اطلاعات بازار به‌روزرسانی شده"""
    query = update.callback_query
    if query:
        await query.answer()
        await query.edit_message_text("⏳ در حال دریافت آمار بازار...")

    try:
        # دریافت اطلاعات از APIهای مختلف
        btc_dominance_data = coinstats_service.get_btc_dominance()
        fear_greed_data = coinstats_service.get_fear_and_greed()
        global_data = direct_api_service.coingecko_global()
        
        # فرمت کردن پیام
        message = "🪙 **منوی رمزارز**\n\n"
        
        # دامیننس بیتکوین
        if not btc_dominance_data.get("error"):
            btc_dom = btc_dominance_data.get("btcDominance", 0)
            message += f"₿ **دامیننس بیتکوین:** {btc_dom:.2f}%\n"
        
        # شاخص ترس و طمع
        if not fear_greed_data.get("error"):
            fear_greed = fear_greed_data.get("value", 0)
            fear_greed_text = fear_greed_data.get("valueClassification", "نامشخص")
            message += f"😱 **شاخص ترس و طمع:** {fear_greed} ({fear_greed_text})\n"
        
        # آمار کلی بازار
        if not global_data.get("error") and "data" in global_data:
            data = global_data["data"]
            total_market_cap = data.get("total_market_cap", {}).get("usd", 0)
            total_volume = data.get("total_volume", {}).get("usd", 0)
            market_cap_change = data.get("market_cap_change_percentage_24h_usd", 0)
            
            message += f"📊 **کل بازار:** ${total_market_cap:,.0f}\n"
            message += f"📈 **حجم 24ساعته:** ${total_volume:,.0f}\n"
            message += f"📉 **تغییر 24ساعته:** {market_cap_change:+.2f}%\n"
        
        message += "\n🔹 لطفاً یکی از گزینه‌ها را انتخاب کنید:"
        
        # دکمه‌های منو
        keyboard = [
            [InlineKeyboardButton("🔄 نارموون دکس", callback_data="narmoon_dex")],
            [InlineKeyboardButton("💰 نارموون کوین", callback_data="narmoon_coin")],
            [InlineKeyboardButton("🔙 بازگشت به منوی اصلی", callback_data="main_menu")]
        ]

        if query:
            await query.edit_message_text(
                message,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )
        else:
            await update.message.reply_text(
                message,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )

    except Exception as e:
        print(f"Error in crypto_menu: {e}")
        error_message = "🪙 **منوی رمزارز**\n\nلطفاً یکی از گزینه‌ها را انتخاب کنید:"
        keyboard = [
            [InlineKeyboardButton("🔄 نارموون دکس", callback_data="narmoon_dex")],
            [InlineKeyboardButton("💰 نارموون کوین", callback_data="narmoon_coin")],
            [InlineKeyboardButton("🔙 بازگشت", callback_data="main_menu")]
        ]

        if query:
            await query.edit_message_text(
                error_message,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )
        else:
            await update.message.reply_text(
                error_message,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )

    return CRYPTO_MENU

async def dex_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """منوی نارموون دکس"""
    query = update.callback_query
    await query.answer()

    user_id = update.effective_user.id
    has_premium = check_subscription(user_id)

    dex_options = {
        'token_info': '🔍 اطلاعات توکن',
        'trending_tokens': '🔥 توکن‌های ترند', 
        'recently_updated': '🔄 توکن‌های به‌روزرسانی شده',
        'boosted_tokens': '🚀 توکن‌های تقویت‌شده',
        'token_snipers': '🎯 اسنایپرهای توکن',
        'token_holders': '👥 بررسی هولدرهای توکن'
    }

    keyboard = []
    for key, label in dex_options.items():
        # گزینه‌های نیازمند آدرس توکن
        input_required = key in ['token_info', 'token_snipers', 'token_holders']
        
        if not has_premium and input_required:
            label = f"🔒 {label}"
        
        keyboard.append([InlineKeyboardButton(label, callback_data=f"dex_{key}")])

    keyboard.append([InlineKeyboardButton("🔙 بازگشت", callback_data="crypto")])

    await query.edit_message_text(
        "🔄 **نارموون دکس**\n\n"
        "تحلیل تخصصی توکن‌های DEX سولانا\n\n"
        "لطفاً یکی از گزینه‌ها را انتخاب کنید:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )

    return DEX_MENU

async def coin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """منوی نارموون کوین"""
    query = update.callback_query
    await query.answer()

    user_id = update.effective_user.id
    has_premium = check_subscription(user_id)

    coin_options = {
        'general_search': '🔎 جستجوی عمومی',
        'trending_coins': '🔥 کوین‌های ترند',
        'global_stats': '🌍 آمار جهانی کریپتو',
        'defi_stats': '🏦 آمار DeFi',
        'companies_treasury': '🏢 ذخایر شرکت‌ها'
    }

    keyboard = []
    for key, label in coin_options.items():
        free_features = ['general_search', 'trending_coins', 'global_stats']
        if not has_premium and key not in free_features:
            label = f"🔒 {label}"
        
        keyboard.append([InlineKeyboardButton(label, callback_data=f"coin_{key}")])

    keyboard.append([InlineKeyboardButton("🔙 بازگشت", callback_data="crypto")])

    await query.edit_message_text(
        "💰 **نارموون کوین**\n\n"
        "تحلیل تخصصی کوین‌های معتبر و بازارهای متمرکز\n\n"
        "لطفاً یکی از گزینه‌ها را انتخاب کنید:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )

    return COIN_MENU

async def handle_dex_option(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """پردازش گزینه‌های منوی دکس"""
    query = update.callback_query
    await query.answer()

    option = query.data.replace("dex_", "")
    user_id = update.effective_user.id
    has_premium = check_subscription(user_id)

    # بررسی دسترسی
    premium_required = option in ['token_info', 'token_snipers', 'token_holders']
    if not has_premium and premium_required:
        await query.answer("⚠️ این قابلیت نیاز به اشتراک دارد", show_alert=True)
        return DEX_MENU

    # بررسی محدودیت API
    if not check_user_api_limit(user_id, has_premium):
        await query.edit_message_text(
            "⚠️ محدودیت روزانه درخواست‌های شما به پایان رسیده است.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("🔙 بازگشت", callback_data="narmoon_dex")
            ]])
        )
        return DEX_MENU

    await query.edit_message_text("⏳ در حال دریافت اطلاعات...")

    try:
        log_api_request(user_id, f"dex_{option}")

        if option == 'token_info':
            context.user_data['waiting_for'] = 'token_address'
            context.user_data['action_type'] = 'token_info'
            
            await query.edit_message_text(
                "🔍 **اطلاعات توکن**\n\n"
                "لطفاً آدرس قرارداد توکن سولانا را ارسال کنید:\n\n"
                "مثال: `7GCihgDB8fe6KNjn2MYtkzZcRjQy3t9GHdC8uHYmW2hr`\n\n"
                "برای لغو: /cancel",
                parse_mode='Markdown'
            )
            return DEX_SUBMENU

        elif option == 'trending_tokens':
            # نمایش زیرمنوی توکن‌های ترند
            keyboard = [
                [InlineKeyboardButton("🌍 همه شبکه‌ها", callback_data="trending_all_networks")],
                [InlineKeyboardButton("🔗 سولانا فقط", callback_data="trending_solana_only")],
                [InlineKeyboardButton("🔙 بازگشت", callback_data="narmoon_dex")]
            ]
            
            await query.edit_message_text(
                "🔥 **توکن‌های ترند**\n\n"
                "لطفاً یکی از گزینه‌ها را انتخاب کنید:",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )
            return DEX_MENU

        elif option == 'recently_updated':
            data = direct_api_service.geckoterminal_recently_updated()
            message = format_recently_updated_tokens(data)
            
        elif option == 'boosted_tokens':
            data = direct_api_service.dexscreener_boosted_tokens()
            message = format_boosted_tokens(data)
            
        elif option == 'token_snipers':
            context.user_data['waiting_for'] = 'pair_address'
            context.user_data['action_type'] = 'token_snipers'
            
            await query.edit_message_text(
                "🎯 **اسنایپرهای توکن**\n\n"
                "لطفاً آدرس جفت (Pair Address) را ارسال کنید:\n\n"
                "برای لغو: /cancel",
                parse_mode='Markdown'
            )
            return DEX_SUBMENU
            
        elif option == 'token_holders':
            context.user_data['waiting_for'] = 'token_contract'
            context.user_data['action_type'] = 'token_holders'
            
            await query.edit_message_text(
                "👥 **بررسی هولدرهای توکن**\n\n"
                "لطفاً آدرس قرارداد توکن سولانا را ارسال کنید:\n\n"
                "مثال: `7GCihgDB8fe6KNjn2MYtkzZcRjQy3t9GHdC8uHYmW2hr`\n\n"
                "برای لغو: /cancel",
                parse_mode='Markdown'
            )
            return DEX_SUBMENU

        else:
            message = "🚧 این بخش در حال توسعه است..."

        # دکمه بازگشت
        keyboard = [[InlineKeyboardButton("🔙 بازگشت", callback_data="narmoon_dex")]]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )

    except Exception as e:
        print(f"Error in handle_dex_option: {e}")
        await query.edit_message_text(
            format_error_message("general"),
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("🔙 بازگشت", callback_data="narmoon_dex")
            ]])
        )

    return DEX_MENU

async def handle_coin_option(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """پردازش گزینه‌های منوی کوین"""
    query = update.callback_query
    await query.answer()

    option = query.data.replace("coin_", "")
    user_id = update.effective_user.id
    has_premium = check_subscription(user_id)

    # بررسی دسترسی
    free_features = ['general_search', 'trending_coins', 'global_stats']
    if not has_premium and option not in free_features:
        await query.answer("⚠️ این قابلیت نیاز به اشتراک دارد", show_alert=True)
        return COIN_MENU

    # بررسی محدودیت API
    if not check_user_api_limit(user_id, has_premium):
        await query.edit_message_text(
            "⚠️ محدودیت روزانه درخواست‌های شما به پایان رسیده است.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("🔙 بازگشت", callback_data="narmoon_coin")
            ]])
        )
        return COIN_MENU

    await query.edit_message_text("⏳ در حال دریافت اطلاعات...")

    try:
        log_api_request(user_id, f"coin_{option}")

        if option == 'general_search':
            context.user_data['waiting_for'] = 'search_query'
            context.user_data['action_type'] = 'general_search'
            
            await query.edit_message_text(
                "🔎 **جستجوی عمومی**\n\n"
                "لطفاً نام یا نماد کوین مورد نظر را وارد کنید:\n\n"
                "مثال: Bitcoin یا BTC\n\n"
                "برای لغو: /cancel",
                parse_mode='Markdown'
            )
            return DEX_SUBMENU  # استفاده از همان state

        elif option == 'trending_coins':
            data = direct_api_service.coingecko_trending()
            message = format_trending_coins(data)
            
        elif option == 'global_stats':
            data = direct_api_service.coingecko_global()
            message = format_global_stats(data)
            
        elif option == 'defi_stats':
            data = direct_api_service.coingecko_defi()
            message = format_defi_stats(data)
            
        elif option == 'companies_treasury':
            # دکمه‌های انتخاب کوین
            keyboard = [
                [InlineKeyboardButton("₿ Bitcoin", callback_data="treasury_bitcoin")],
                [InlineKeyboardButton("Ξ Ethereum", callback_data="treasury_ethereum")],
                [InlineKeyboardButton("🔙 بازگشت", callback_data="narmoon_coin")]
            ]
            
            await query.edit_message_text(
                "🏢 **ذخایر شرکت‌ها**\n\n"
                "لطفاً کوین مورد نظر را انتخاب کنید:",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )
            return COIN_MENU

        else:
            message = "🚧 این بخش در حال توسعه است..."

        # دکمه بازگشت
        keyboard = [[InlineKeyboardButton("🔙 بازگشت", callback_data="narmoon_coin")]]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )

    except Exception as e:
        print(f"Error in handle_coin_option: {e}")
        await query.edit_message_text(
            format_error_message("general"),
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("🔙 بازگشت", callback_data="narmoon_coin")
            ]])
        )

    return COIN_MENU

async def handle_trending_options(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """پردازش گزینه‌های توکن‌های ترند"""
    query = update.callback_query
    await query.answer()

    option = query.data
    await query.edit_message_text("⏳ در حال دریافت توکن‌های ترند...")

    try:
        if option == "trending_all_networks":
            data = direct_api_service.geckoterminal_trending_all()
            message = format_trending_all_networks(data)
            
        elif option == "trending_solana_only":
            # ترکیب داده‌ها از GeckoTerminal و Moralis
            combined_data = await direct_api_service.get_combined_solana_trending()
            message = format_combined_solana_trending(combined_data)

        # دکمه بازگشت
        keyboard = [[InlineKeyboardButton("🔙 بازگشت به دکس", callback_data="narmoon_dex")]]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )

    except Exception as e:
        print(f"Error in handle_trending_options: {e}")
        await query.edit_message_text(
            format_error_message("general"),
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("🔙 بازگشت", callback_data="narmoon_dex")
            ]])
        )

    return DEX_MENU

async def handle_treasury_options(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """پردازش گزینه‌های ذخایر شرکت‌ها"""
    query = update.callback_query
    await query.answer()

    coin_id = query.data.replace("treasury_", "")
    await query.edit_message_text("⏳ در حال دریافت اطلاعات ذخایر...")

    try:
        data = direct_api_service.coingecko_companies_treasury(coin_id)
        message = format_companies_treasury(data, coin_id)

        keyboard = [[InlineKeyboardButton("🔙 بازگشت به کوین", callback_data="narmoon_coin")]]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )

    except Exception as e:
        print(f"Error in handle_treasury_options: {e}")
        await query.edit_message_text(
            format_error_message("general"),
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("🔙 بازگشت", callback_data="narmoon_coin")
            ]])
        )

    return COIN_MENU

async def process_user_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """پردازش ورودی‌های کاربر"""
    waiting_for = context.user_data.get('waiting_for')
    action_type = context.user_data.get('action_type')
    
    if not waiting_for or not action_type:
        return DEX_SUBMENU

    user_input = update.message.text.strip()
    await update.message.reply_text("🔍 در حال پردازش...")

    try:
        if action_type == 'token_info':
            # اطلاعات توکن از GeckoTerminal
            data = direct_api_service.geckoterminal_token_info("solana", user_input)
            message = format_token_info(data)
            
        elif action_type == 'token_snipers':
            # اسنایپرهای توکن از Moralis
            data = direct_api_service.moralis_snipers(user_input)
            message = format_snipers_info(data)
            
        elif action_type == 'token_holders':
            # اطلاعات هولدرها از HolderScan
            holders_data = holderscan_service.token_holders(user_input, limit=20)
            stats_data = holderscan_service.token_stats(user_input)
            deltas_data = holderscan_service.holder_deltas(user_input)
            
            message = format_holders_info(holders_data, stats_data, deltas_data)
            
        elif action_type == 'general_search':
            # جستجوی عمومی از CoinGecko
            data = direct_api_service.coingecko_search(user_input)
            message = format_search_results(data)

        else:
            message = "❌ نوع عملیات شناسایی نشد."

        # دکمه‌های بازگشت
        if action_type in ['token_info', 'token_snipers', 'token_holders']:
            back_button = "narmoon_dex"
        else:
            back_button = "narmoon_coin"
            
        keyboard = [
            [InlineKeyboardButton(f"🔙 بازگشت", callback_data=back_button)]
        ]

        await update.message.reply_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )

        # پاک کردن وضعیت
        context.user_data.clear()
        return CRYPTO_MENU

    except Exception as e:
        print(f"Error in process_user_input: {e}")
        await update.message.reply_text(
            format_error_message("general"),
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("🔙 بازگشت", callback_data="crypto")
            ]])
        )
        context.user_data.clear()
        return CRYPTO_MENU

# === Helper Functions for Formatting ===

def format_recently_updated_tokens(data):
    """فرمت کردن توکن‌های به‌روزرسانی شده"""
    if data.get("error") or "data" not in data:
        return "❌ خطا در دریافت اطلاعات توکن‌های به‌روزرسانی شده."
    
    message = "🔄 **توکن‌های به‌روزرسانی شده**\n\n"
    
    tokens = data["data"].get("tokens", [])[:10]
    for i, token in enumerate(tokens, 1):
        attributes = token.get("attributes", {})
        name = attributes.get("name", "نامشخص")
        symbol = attributes.get("symbol", "???")
        address = attributes.get("address", "")[:8] + "..."
        
        message += f"{i}. **{name}** ({symbol})\n"
        message += f"   📍 {address}\n\n"
    
    return message

def format_boosted_tokens(data):
    """فرمت کردن توکن‌های تقویت‌شده"""
    if not isinstance(data, list) or not data:
        return "❌ هیچ توکن تقویت‌شده‌ای یافت نشد."
    
    message = "🚀 **توکن‌های تقویت‌شده**\n\n"
    
    tokens = data[:10]
    for i, token in enumerate(tokens, 1):
        # استخراج نام توکن از URL یا آدرس
        token_address = token.get("tokenAddress", "")
        description = token.get("description", "")
        
        # تلاش برای استخراج نام از description
        name = "نامشخص"
        symbol = "???"
        
        if description:
            # جستجو برای نام در توضیحات
            desc_words = description.split()
            for word in desc_words:
                if word.startswith("$") and len(word) > 1:
                    symbol = word[1:]  # حذف $
                    name = word
                    break
        
        if token_address:
            symbol = token_address[:6] + "..."
        
        message += f"{i}. **{name}** ({symbol})\n"
        if description:
            # نمایش بخش کوتاهی از توضیحات
            short_desc = description[:50] + "..." if len(description) > 50 else description
            message += f"   📝 {short_desc}\n"
        message += "\n"
    
    return message

def format_trending_coins(data):
    """فرمت کردن کوین‌های ترند"""
    if data.get("error") or "coins" not in data:
        return "❌ خطا در دریافت کوین‌های ترند."
    
    message = "🔥 **کوین‌های ترند**\n\n"
    
    coins = data["coins"][:10]
    for i, coin_data in enumerate(coins, 1):
        item = coin_data.get("item", {})
        name = item.get("name", "نامشخص")
        symbol = item.get("symbol", "???").upper()
        market_cap_rank = item.get("market_cap_rank", "N/A")
        
        message += f"{i}. **{name}** ({symbol})\n"
        message += f"   📊 رنک: #{market_cap_rank}\n\n"
    
    return message

def format_global_stats(data):
    """فرمت کردن آمار جهانی"""
    if data.get("error") or "data" not in data:
        return "❌ خطا در دریافت آمار جهانی."
    
    stats = data["data"]
    message = "🌍 **آمار جهانی کریپتو**\n\n"
    
    # کل بازار
    total_market_cap = stats.get("total_market_cap", {}).get("usd", 0)
    message += f"💰 **کل بازار:** ${total_market_cap:,.0f}\n"
    
    # حجم معاملات
    total_volume = stats.get("total_volume", {}).get("usd", 0)
    message += f"📈 **حجم 24ساعته:** ${total_volume:,.0f}\n"
    
    # دامیننس
    btc_dominance = stats.get("market_cap_percentage", {}).get("btc", 0)
    eth_dominance = stats.get("market_cap_percentage", {}).get("eth", 0)
    message += f"₿ **دامیننس BTC:** {btc_dominance:.1f}%\n"
    message += f"Ξ **دامیننس ETH:** {eth_dominance:.1f}%\n"
    
    # تعداد کوین‌ها
    active_cryptocurrencies = stats.get("active_cryptocurrencies", 0)
    message += f"🪙 **کوین‌های فعال:** {active_cryptocurrencies:,}\n"
    
    # تغییر 24 ساعته
    market_cap_change = stats.get("market_cap_change_percentage_24h_usd", 0)
    message += f"📊 **تغییر 24ساعته:** {market_cap_change:+.2f}%\n"
    
    return message

def format_defi_stats(data):
    """فرمت کردن آمار DeFi"""
    if data.get("error") or "data" not in data:
        return "❌ خطا در دریافت آمار DeFi."
    
    stats = data["data"]
    message = "🏦 **آمار DeFi**\n\n"
    
    # کل بازار DeFi
    defi_market_cap = stats.get("defi_market_cap", 0)
    message += f"💎 **کل بازار DeFi:** ${defi_market_cap:,.0f}\n"
    
    # درصد از کل بازار
    defi_dominance = stats.get("defi_to_eth_ratio", 0) * 100
    message += f"📊 **سهم از کل بازار:** {defi_dominance:.2f}%\n"
    
    # حجم معاملات DeFi
    trading_volume = stats.get("trading_volume_24h", 0)
    message += f"📈 **حجم معاملات 24ساعته:** ${trading_volume:,.0f}\n"
    
    return message

def format_companies_treasury(data, coin_id):
    """فرمت کردن ذخایر شرکت‌ها"""
    if data.get("error") or "companies" not in data:
        return f"❌ خطا در دریافت اطلاعات ذخایر {coin_id}."
    
    coin_name = "Bitcoin" if coin_id == "bitcoin" else "Ethereum"
    symbol = "BTC" if coin_id == "bitcoin" else "ETH"
    
    message = f"🏢 **ذخایر {coin_name} شرکت‌ها**\n\n"
    
    companies = data["companies"][:10]
    total_holdings = 0
    
    for i, company in enumerate(companies, 1):
        name = company.get("name", "نامشخص")
        holdings = company.get("total_holdings", 0)
        total_holdings += holdings
        
        message += f"{i}. **{name}**\n"
        message += f"   💰 {holdings:,.0f} {symbol}\n\n"
    
    message += f"📊 **مجموع ده شرکت برتر:** {total_holdings:,.0f} {symbol}\n"
    
    return message

def format_trending_all_networks(data):
    """فرمت کردن توکن‌های ترند همه شبکه‌ها"""
    if data.get("error") or "data" not in data:
        return "❌ خطا در دریافت توکن‌های ترند."
    
    message = "🌍 **توکن‌های ترند همه شبکه‌ها**\n\n"
    
    pools = data["data"].get("pools", [])[:10]
    for i, pool in enumerate(pools, 1):
        attributes = pool.get("attributes", {})
        base_token = attributes.get("base_token", {})
        
        name = base_token.get("name", "نامشخص")
        symbol = base_token.get("symbol", "???")
        network = pool.get("relationships", {}).get("dex", {}).get("data", {}).get("id", "نامشخص")
        price_change = attributes.get("price_change_percentage", {}).get("h24", 0)
        
        message += f"{i}. **{name}** ({symbol})\n"
        message += f"   🌐 {network}\n"
        message += f"   📈 تغییر 24س: {price_change:+.2f}%\n\n"
    
    return message

def format_combined_solana_trending(data):
    """فرمت کردن توکن‌های ترند سولانا ترکیبی"""
    if not data.get("success"):
        return "❌ خطا در دریافت توکن‌های ترند سولانا."
    
    message = "🔗 **توکن‌های ترند سولانا**\n\n"
    
    tokens = data.get("combined_tokens", [])[:15]
    for i, token in enumerate(tokens, 1):
        name = token.get("name", "نامشخص")
        symbol = token.get("symbol", "???")
        source = token.get("source", "نامشخص")
        
        # تبدیل ایمن price_change به float
        try:
            price_change = float(token.get("price_change_24h", 0))
        except (ValueError, TypeError):
            price_change = 0.0
        
        message += f"{i}. **{name}** ({symbol})\n"
        message += f"   📊 منبع: {source}\n"
        message += f"   📈 تغییر 24س: {price_change:+.2f}%\n\n"
    
    message += f"📈 **مجموع:** {len(tokens)} توکن از GeckoTerminal\n"
    
    return message

def format_search_results(data):
    """فرمت کردن نتایج جستجو"""
    if data.get("error"):
        return "❌ خطا در جستجو."
    
    message = "🔎 **نتایج جستجو**\n\n"
    
    # کوین‌ها
    coins = data.get("coins", [])[:5]
    if coins:
        message += "**💰 کوین‌ها:**\n"
        for coin in coins:
            name = coin.get("name", "نامشخص")
            symbol = coin.get("symbol", "???")
            market_cap_rank = coin.get("market_cap_rank")
            
            message += f"• **{name}** ({symbol})"
            if market_cap_rank:
                message += f" - رنک #{market_cap_rank}"
            message += "\n"
        message += "\n"
    
    # صرافی‌ها
    exchanges = data.get("exchanges", [])[:3]
    if exchanges:
        message += "**🏪 صرافی‌ها:**\n"
        for exchange in exchanges:
            name = exchange.get("name", "نامشخص")
            message += f"• {name}\n"
        message += "\n"
    
    if not coins and not exchanges:
        message += "هیچ نتیجه‌ای یافت نشد."
    
    return message

def format_snipers_info(data):
    """فرمت کردن اطلاعات اسنایپرها"""
    if data.get("error"):
        return "❌ خطا در دریافت اطلاعات اسنایپرها."
    
    message = "🎯 **اسنایپرهای توکن**\n\n"
    
    if isinstance(data, list) and data:
        for i, sniper in enumerate(data[:10], 1):
            address = sniper.get("address", "نامشخص")[:8] + "..."
            amount = sniper.get("amount", 0)
            
            message += f"{i}. **آدرس:** {address}\n"
            message += f"   💰 مقدار: {amount}\n\n"
    else:
        message += "هیچ اسنایپری یافت نشد."
    
    return message
